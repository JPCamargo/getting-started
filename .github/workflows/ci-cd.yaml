# Arquivo de workflow GitHub Actions para CI/CD de aplicação Quarkus
# Este workflow executa testes, build da imagem Docker e deploy da aplicação
# em ambiente de dev e prod quando um pull request for mesclado na branch 'main'

name: Pipeline CI/CD Quarkus App

on:
  pull_request:
    types: [closed, opened]  # Executa apenas quando um PR é aberto ou fechado
    branches: [main] # E a branch de destino for 'main'

jobs:
   test:
    if: github.event.action == 'opened'  # Executa somente quando o PR é aberto
    runs-on: ubuntu-latest # Ambiente no qual esse job vai ser executado

    steps:
      - name: Copiar código fonte
        uses: actions/checkout@v3

      - name: SonarQube
        uses: SonarSource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=quarkus_hello
            -Dsonar.verbose=true
#            -Dsonar.exclusions=**/*.java

      - name: Configurar JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Permitir execução do mvnw
        run: chmod +x mvnw

      - name: Executar testes automatizados
        run: ./mvnw test

   build:
    if: github.event.pull_request.state == 'closed' && github.event.pull_request.merged == true  # Garante o merge para branch ‘main’
    runs-on: ubuntu-latest
    outputs:
      commit_hash: ${{ steps.get-hash.outputs.commit }} 

    steps:
      - name: Copiar código fonte
        uses: actions/checkout@v3

      - name: Configurar JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Permitir execução do mvnw
        run: chmod +x mvnw

      - name: Compilar e empacotar aplicação Quarkus
        run: ./mvnw package -DskipTests

      - name: Obter hash do commit para versionamento
        id: get-hash
        run: |
          echo "COMMIT_HASH=$(git rev-parse --short HEAD)" >> $GITHUB_ENV
          echo "commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build da imagem Docker usando hash para versionamento
        run: docker build -t quarkus-app:${{ env.COMMIT_HASH }} .

      - name: Scan de vulnerabilidades com Trivy
        uses: aquasecurity/trivy-action@0.32.0
        with:
          image-ref: quarkus-app:${{ env.COMMIT_HASH }} # Nome da imagem contruída 
          format: table # Exibe resultados em formato legível
          exit-code: 0 # Não falha o step mesmo se encontrar vulnerabilidades
          ignore-unfixed: true # Ignora vulnerabilidade que não tem correção

      - name: Login no Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Push da imagem para o Docker Hub
        run: |
          docker tag quarkus-app:${{ env.COMMIT_HASH }} ${{ secrets.DOCKER_USERNAME }}/quarkus-app:${{ env.COMMIT_HASH }}
          docker push ${{ secrets.DOCKER_USERNAME }}/quarkus-app:${{ env.COMMIT_HASH }}

   deploy-dev:
    if: github.event.pull_request.state == 'closed' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    needs: build # Executa após o build ter executado com sucesso
    env:
      COMMIT_HASH: ${{ needs.build.outputs.commit_hash }}
    
    steps:
      - name: Copiar código fonte
        uses: actions/checkout@v3

      - name: Autenticar no GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      - name: Instalar gcloud com plugin GKE
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: gke-gcloud-auth-plugin

      - name: Configurar acesso ao cluster Kubernetes na GCP
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: quarkus-app-cluster # Nome do k8s criado na GCP
          location: us-central1 # Zona em que k8s foi criado
          project_id: ${{ secrets.GCP_PROJECT_ID }} # project ID do k8s na GCP

      - name: Substituir variáveis nos manifestos k8s para pull da imagem correta
        run: |
          export DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
          export COMMIT_HASH=${{ env.COMMIT_HASH }}
          mkdir -p infra/dev/resolved
          for file in infra/dev/*.yaml; do
            envsubst < "$file" > "infra/dev/resolved/$(basename $file)"
          done

      - name: Aplicar manifestos Kubernetes
        run: kubectl apply -f infra/dev/resolved/

      - name: Validar sucesso do Deployment
        id: validar_deploy_dev
        continue-on-error: true
        run: |
          echo "Verificando rollout do Deployment..."
          kubectl rollout status deployment/quarkus-app-dev --namespace=dev --timeout=30s
      
      - name: Rollback do Deployment em caso de falha
        if: steps.validar_deploy_dev.outcome == 'failure'
        run: |
          echo "Falha no rollout. Iniciando rollback..."
          kubectl rollout undo deployment/quarkus-app-dev --namespace=dev
          echo "Rollback executado. Marcando job como falho."
          exit 1

   deploy-prd:
    if: github.event.pull_request.state == 'closed' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    needs: [build, deploy-dev] # Executa após o build e deploy-dev ter executado com sucesso
    environment: aprovação-deploy-prd # Cria um step de aprovação manual
    env:
      COMMIT_HASH: ${{ needs.build.outputs.commit_hash }}
    
    steps:
      - name: Copiar código fonte
        uses: actions/checkout@v3

      - name: Autenticar no GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      - name: Instalar gcloud com plugin GKE
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: gke-gcloud-auth-plugin

      - name: Configurar acesso ao cluster k8s na GCP
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: quarkus-app-cluster # Nome do k8s criado na GCP
          location: us-central1 # Zona em que k8s foi criado
          project_id: ${{ secrets.GCP_PROJECT_ID }} # project ID do k8s na GCP

      - name: Substituir variáveis nos manifestos k8s para pull da imagem correta
        run: |
          export DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
          export COMMIT_HASH=${{ env.COMMIT_HASH }}
          mkdir -p infra/prod/resolved
          for file in infra/prod/*.yaml; do
            envsubst < "$file" > "infra/prod/resolved/$(basename $file)"
          done

      - name: Aplicar manifestos Kubernetes
        run: kubectl apply -f infra/prod/resolved/

      - name: Validar sucesso do Deployment
        id: validar_deploy_prod
        continue-on-error: true
        run: |
          echo "Verificando rollout do Deployment..."
          kubectl rollout status deployment/quarkus-app-prod --namespace=prod --timeout=300s
      
      - name: Rollback do Deployment em caso de falha
        if: steps.validar_deploy_prod.outcome == 'failure'
        run: |
          echo "Falha no rollout. Iniciando rollback..."
          kubectl rollout undo deployment/quarkus-app-prod --namespace=prod
          echo "Rollback executado. Marcando job como falho."
          exit 1

# Fim do Pipeline CI/CD Quarkus App
