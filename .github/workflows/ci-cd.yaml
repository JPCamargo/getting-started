# Arquivo de workflow GitHub Actions para CI/CD de aplicação Quarkus
# Este workflow executa testes, build da imagem Docker e simula deploy
# Somente quando um pull request for mesclado na branch 'main'

name: CI/CD Quarkus Pipeline

on:
  pull_request:
    types: [closed, opened]  # Executa apenas quando o PR for fechado
    branches: [main] # E a branch de destino for 'main'

jobs:
   test:
    if: github.event.action == 'opened'  # Executar esse job quando o pull request for aberto
    runs-on: ubuntu-latest

    steps:
      # Etapa 1: Checkout do código-fonte
      - name: Checkout do código
        uses: actions/checkout@v3

      # Etapa 2: Configuração do Java 17 (necessário para Quarkus)
      - name: Configurar JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Etapa 3: Permissão de execução para o wrapper do Maven
      - name: Permitir execução do mvnw
        run: chmod +x mvnw

      # Etapa 4: Executar testes automatizados (JUnit/RestAssured)
      - name: Executar testes automatizados
        run: ./mvnw test
  
   build:
    if: github.event.pull_request.state == 'closed' && github.event.pull_request.merged == true  # Garante que o PR foi realmente mesclado
    runs-on: ubuntu-latest

    steps:
      # Etapa 1: Checkout do código-fonte
      - name: Checkout do código
        uses: actions/checkout@v3

      # Etapa 2: Configuração do Java 17 (necessário para Quarkus)
      - name: Configurar JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Etapa 3: Permissão de execução para o wrapper do Maven
      - name: Permitir execução do mvnw
        run: chmod +x mvnw

      # Etapa 5: Compilar e empacotar a aplicação (sem rodar testes novamente)
      - name: Compilar e empacotar aplicação Quarkus
        run: ./mvnw package -DskipTests

      # Etapa 6: Obter o hash do commit para versionar a imagem Docker
      - name: Obter hash do commit
        run: echo "COMMIT_HASH=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      # Etapa 7: Build da imagem Docker com tag baseada no hash do commit
      - name: Build da imagem Docker
        run: docker build -t quarkus-app:${{ env.COMMIT_HASH }} .

      # Etapa 8: Login no Docker Hub (requer segredos DOCKER_USERNAME e DOCKER_PASSWORD)
      - name: Login no Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # Etapa 9: Push da imagem para o Docker Hub
      - name: Push da imagem para o Docker Hub
        run: |
          docker tag quarkus-app:${{ env.COMMIT_HASH }} ${{ secrets.DOCKER_USERNAME }}/quarkus-app:${{ env.COMMIT_HASH }}
          docker push ${{ secrets.DOCKER_USERNAME }}/quarkus-app:${{ env.COMMIT_HASH }}

      - name: Autenticar no GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}


      - name: Instalar gcloud com plugin GKE
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: gke-gcloud-auth-plugin

      - name: Configurar acesso ao cluster GKE
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: quarkus-app-cluster
          location: us-central1
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Substituir variáveis nos manifestos
        run: |
          export DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
          export COMMIT_HASH=${{ env.COMMIT_HASH }}
          mkdir -p infra/dev/resolved
          for file in infra/dev/*.yaml; do
            envsubst < "$file" > "infra/dev/resolved/$(basename $file)"
          done

      - name: Aplicar manifestos Kubernetes
        run: kubectl apply -f infra/dev/resolved/

      - name: Verificar status dos pods
        run: kubectl get pods


      # Etapa 10: Simulação de deploy no ambiente de desenvolvimento
      - name: Simular deploy no ambiente DEV
        run: echo "Simulação de deploy no ambiente DEV"

      # Etapa 11: Simulação de deploy no ambiente de produção
      - name: Simular deploy no ambiente PROD
        run: echo "Simulação de deploy no ambiente PROD"


#- name: Configurar acesso ao cluster Minikube
#  run: kubectl config use-context minikube

#- name: Aplicar manifestos Kubernetes
#  run: kubectl apply -f k8s/

#- name: Verificar status dos pods
#  run: kubectl get pods
